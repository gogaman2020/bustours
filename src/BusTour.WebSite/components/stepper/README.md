# Описание компонента

Компонент отвечает за логику рендера компонентов в зависимости от определенного шага.

# Использование

Импорт: 

```js
	import Stepper, { IStep } from "~/components/stepper/stepper.vue";
	import Step from "~/components/stepper/step.vue"
```

Далее каждый компонент, отражающий шаг должен был помещен в соответствующий компонент **Step**,  
передавая в *:steps* правило отображения:

```html
	<Stepper v-model="step" :steps="steps">
		<Step :steps="[1]">
			<SomeComponent1 />
		</Step>

		<Step :steps="[2]">
			<SomeComponent2 />
		</Step>
	</Stepper>
```

Указывая в аттрибуте *:steps* компонента **Step** шаги, на которых будет показываться данный компонент.

Данный *props* принимает на вход либо массив, либо функцию,  
первым параметром в которую передается значение текущего шага.  
То есть можно указать условие, при котором компонент виден, основываясь на текущем шаге.

```html
	<Stepper v-model="step" :steps="steps>
		<Step :steps="s => s > 1"> <!-- Показывается, если текущий шаг больше 1  -->
			<SomeComponent1 />
		</Step>

		<Step :steps="() => true"> <!-- Показывается всегда -->
			<SomeComponent2 />
		</Step>
	</Stepper>
```

## Stepper

В компонент **Stepper** необходимо передать массив шагов в *:steps*. Каждый шаг должен быть типа ```IStep```.  
Указывая breakpoint (в пикселях либо без единиц измерения) для шага можно управлять его видимостью на определенном разрешении, например: 

```html
	<Stepper v-model="step" :steps="steps">
		<Step :steps="[1]">
			<SomeComponent1 />
		</Step>

		<Step :steps="[2]">
			<SomeComponent2 />
		</Step>

		<Step :steps="[3]">
			<SomeComponent3 />
		</Step>
	</Stepper>

	...

	data() {
		return {
			steps: [
				{ value: 1 },
				{ value: 2, breakpoint: "360px" },
				{ value: 3, }
			],
			step: 1,
		}
	}
```

В данном примере, на разрешении > 360px будет показываться лишь шаги 1 и 3, шаг 2 будет пропущен.  
На разрешении <= 360px шаг 2 будет учавстовать в процессе.

Для переключения шагов степпера необходимо в его родительском компоненте вызывать события *stepper-next* и *stepper-prev* соответственно.  
При вызове можно указать "сдвиг" шагов. По умолчанию - 1. Параметр отвечает размер шага: 1 - слеующий шаг, 2 - через один и т.д. 
Также необходимо привязаться к степперу с помощью *v-model*, тем самым указав шаг, с которого степперу стоит начинать свою работу.  
Также благодаря этому мы реактивно получем изменения шагов, а также возможность менять текущий шаг форсированно.  

## Step

Компонент **Step** поддерживает динамическое переключение контента внутри себя.  
Передавая в props *:breakpoints* массив breakpoint`ов с единицами измерения или без мы получаем возможность  
отрисовывать определенные компоненты при преодолении заданных точек, указывая эти компоненты в именованных слотах,  
названия которых формируются исходя из переданныз breakpoints. Например: 

```html
	<Step :steps="[1]" :breakpoints="['1000px', '500px']">
		<BigButton />

		<template #breakpoint1000px>
			<MiddleButton />
		</template>

		<template #breakpoint500px>
			<SmallButton />
		</template>
	</Step>
```

До разрешения 1000px будет показываться лишь компонент *BigButton*, однако при преодолении первой заданной точки в *1000px*,  
будет показан лишь компонент *MiddleButton*, указанный в соответсвующем слоте. Затем при преодолении рубежа в *500px* вместо  
*MiddleButton* будет уже отрисован *SmallButton*.
Также может понадобиться лишь добавлять какой-то компонент при преодолении breakpoint, а не заменять все имеющиеся.  
Для такого случае предусмотрен именованный слот *always*, который не будет скрывать имеющиеся компоненты при преодолении точки останова. Пример: 

```html
	<Step :steps="[1]" :breakpoints="['1000px']">
		<template #always>
			<Title />
		</template>

		<template #breakpoint1000px>
			<SubTitle />
		</template>
	</Step>
```

Здесь компонент *Title* будет показываться всегда, а при преодолении 1000px появиться *SubTitle*.